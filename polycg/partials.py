from __future__ import annotations

import sys
import numpy as np
from typing import Tuple, List, Callable, Any, Dict
from .utils.bmat import BlockOverlapMatrix
from .transforms.transform_statevec import statevec2vecs

PARTIALS_MIN_BLOCK = 4

#######################################################################################
#######################################################################################


def partial_stiff(
    seq: str,
    stiffgen_method: Callable,
    stiffgen_args: Dict[str, Any],
    block_size: int,
    overlap_size: int,
    tail_size: int,
    closed: bool = False,
    ndims: int = 6,
) -> Tuple[np.ndarray, BlockOverlapMatrix]:
    """
    Assemble a global stiffness matrix and ground-state vector by stitching local stiffness blocks.

    The sequence is processed in overlapping segments. For each segment, an extended
    subsequence is generated by adding `tail_size` base pairs on both sides (with
    periodic extension if `closed=True`). The provided `stiffgen_method` is applied
    to this extended subsequence to obtain a local ground-state vector and stiffness
    matrix. Tail contributions are removed, and the remaining segment contribution is
    inserted into a global BlockOverlapMatrix over the corresponding index range.

    Overlapping segments contribute multiple times to the same degrees of freedom.
    The returned ground-state vector is computed as the arithmetic mean over all
    segment contributions. The returned stiffness is stored as overlapping dense
    blocks; overlap handling on extraction is governed by the BlockOverlapMatrix
    averaging semantics.

    Parameters
    ----------
    seq : str
        DNA sequence used to generate stiffness. If `closed=False`, the final
        base-pair step (connecting last to first) is excluded from the global system.
        If `closed=True`, the sequence is treated as cyclic.
    stiffgen_method : Callable
        Function that generates a ground-state vector and stiffness matrix for a
        given sequence. It must return `(gs, stiff)` where `gs` is a 1D array-like
        of length `ndims * nsteps` and `stiff` is a 2D array-like of shape
        `(ndims * nsteps, ndims * nsteps)`.
    stiffgen_args : dict
        Keyword arguments forwarded to `stiffgen_method`.
    block_size : int
        Number of base-pair steps included in each segment contribution (before
        adding tails). Segments are placed with stride `block_size - overlap_size`.
    overlap_size : int
        Number of base-pair steps shared between neighboring segments. Must satisfy
        `0 <= overlap_size < block_size` and must not exceed the number of steps in
        the global system.
    tail_size : int
        Number of additional base pairs included on each side of a segment when
        calling `stiffgen_method`. Tail regions are discarded from the returned
        segment contribution to reduce boundary artifacts.
    closed : bool, default False
        If True, treat the sequence as cyclic and assemble a periodic stiffness
        matrix with size `len(seq) * ndims`. If False, assemble a linear stiffness
        matrix with size `(len(seq) - 1) * ndims`.
    ndims : int, default 6
        Number of degrees of freedom per base-pair step.

    Returns
    -------
    gs : numpy.ndarray
        Ground-state vector reshaped by `statevec2vecs(gs, ndims)` after averaging
        across segment contributions.
    stiff : BlockOverlapMatrix
        Global stiffness represented as overlapping dense blocks. The stiffness
        matrix can be converted to a SciPy sparse matrix using `stiff.to_sparse()`.

    Raises
    ------
    ValueError
        If `overlap_size > nbps` where `nbps` is the number of steps in the assembled
        system, or if `block_size <= overlap_size`, or if `block_size + tail_size`
        is smaller than `PARTIALS_MIN_BLOCK`.
    """
    
    nbps = len(seq)
    if not closed:
        nbps -= 1
    if overlap_size > nbps:
        raise ValueError(f"Overlap size should not exceed the number of bps!")

    if block_size <= overlap_size:
        raise ValueError(
            f"block_size ({block_size}) needs to be larger than overlap_size ({overlap_size})."
        )

    if block_size + tail_size < PARTIALS_MIN_BLOCK:
        raise ValueError(
            f"blocks too small. block_size+tail_size={block_size+tail_size}. Needs to be at least {PARTIALS_MIN_BLOCK}."
        )
        
    if closed:
        gs,stiff = _partial_stiff_closed(
            seq,
            stiffgen_method,
            stiffgen_args,
            block_size,
            overlap_size,
            tail_size,
            ndims=ndims,
        )
    else:
        gs, stiff = _partial_stiff_linear(
            seq,
            stiffgen_method,
            stiffgen_args,
            block_size,
            overlap_size,
            tail_size,
            ndims=ndims,
        )
    # if isinstance(stiff,BlockOverlapMatrix):
    #     print('convert to sparse')
    #     stiff = stiff.to_sparse()
    return gs, stiff


#######################################################################################
#######################################################################################


def _partial_stiff_linear(
    seq: str,
    stiffgen_method: Callable,
    stiffgen_args: Dict[str, Any],
    block_size: int,
    overlap_size: int,
    tail_size: int,
    ndims: int = 6,
) -> Tuple[np.ndarray, BlockOverlapMatrix]:
    Nseq = len(seq)
    N = Nseq - 1
    block_incr = block_size - overlap_size
    Nsegs = int(np.floor((N - overlap_size) / block_incr))
    lastseg_id = Nsegs - 1

    stiff = BlockOverlapMatrix(
        average=True,
        periodic=False,
        fixed_size=True,
        xlo=0,
        xhi=N * ndims,
        ylo=0,
        yhi=N * ndims,
    )
    gs = np.zeros(ndims * N)
    cnts = np.zeros(ndims * N)

    for i in range(Nsegs):
        # block range
        id1 = i * block_incr
        id2 = id1 + block_size
        if id2 > N:
            id2 = N

        if i == lastseg_id:
            id2 = N
        assert id2 <= N, "bu exceeds bounds for seg other than last."

        print(f"Generating stiffness from bps {id1} to {id2} ({N} in total).")

        pgs, pstiff = _extract_bps_stiff(
            seq,
            id1,
            id2,
            tail_size,
            stiffgen_method,
            stiffgen_args,
            ndims,
            periodic=False,
        )
        mid1 = id1 * ndims
        mid2 = id2 * ndims
        stiff.add_block(pstiff, mid1, mid2, y1=mid1, y2=mid2)

        if id2 <= N:
            gs[mid1:mid2] += pgs
            cnts[mid1:mid2] += 1
        else:
            mid2 = N * ndims
            gs[mid1:mid2] += pgs[: mid2 - mid1]
            cnts[mid1:mid2] += 1
    gs /= cnts
    gs = statevec2vecs(gs,ndims)
    return gs, stiff


#######################################################################################
#######################################################################################


def _partial_stiff_closed(
    seq: str,
    stiffgen_method: Callable,
    stiffgen_args: Dict[str, Any],
    block_size: int,
    overlap_size: int,
    tail_size: int,
    ndims: int = 6,
) -> Tuple[np.ndarray, BlockOverlapMatrix]:
    # the main sequence includes the step connecting the last and first bp
    # the full sequence includes the overlap region on top of that

    N_main = len(seq)
    N_full = N_main + overlap_size
    
    if block_size > N_main - overlap_size:
        block_size = int(np.ceil(N_main / 2))

    block_incr = block_size - overlap_size
    Nsegs = int(np.floor(N_full / block_incr))
    lastseg_id = Nsegs - 1

    stiff = BlockOverlapMatrix(
        average=True,
        periodic=True,
        xlo=0,
        xhi=N_main * ndims,
        ylo=0,
        yhi=N_main * ndims,
    )
    gs = np.zeros(ndims * N_main)
    cnts = np.zeros(ndims * N_main)

    for i in range(Nsegs):
        # block range
        id1 = i * block_incr
        id2 = id1 + block_size

        if i == lastseg_id and id2 < N_full:
            id2 = N_full
            
        print(f"Generating stiffness from bps {id1} to {id2} ({N_full} in total).")

        pgs, pstiff = _extract_bps_stiff(
            seq,
            id1,
            id2,
            tail_size,
            stiffgen_method,
            stiffgen_args,
            ndims,
            periodic=True,
        )

        mid1 = id1 * ndims
        mid2 = id2 * ndims

        stiff.add_block(pstiff, mid1, mid2, y1=mid1, y2=mid2)

        if id2 <= N_main:
            gs[mid1:mid2] += pgs
            cnts[mid1:mid2] += 1
        else:
            mid2 = N_main * ndims
            gs[mid1:mid2] += pgs[: mid2 - mid1]
            cnts[mid1:mid2] += 1
    gs /= cnts
    gs = statevec2vecs(gs,ndims)
    return gs, stiff


#######################################################################################
#######################################################################################


def _extract_bps_stiff(
    seq: str,
    id1: int,
    id2: int,
    tail_size: int,
    stiffgen_method: Callable,
    stiffgen_args: Dict[str, Any],
    ndims: int = 6,
    periodic: bool = False,
) -> Tuple[np.ndarray, np.ndarray, int, int]:
    sid1 = id1
    sid2 = id2 + 1

    if not periodic:
        if sid1 < 0:
            raise IndexError(
                f"Lower bound ({id1}) cannot be negative for non-periodic boundary."
            )
        if sid2 > len(seq):
            raise IndexError(
                f"Upper bound ({id2}) out of bounds for sequence of length {len(seq)}."
            )

        ladd_id = sid1 - tail_size
        uadd_id = sid2 + tail_size
        if ladd_id < 0:
            ladd_id = 0
        if uadd_id > len(seq):
            uadd_id = len(seq)
        genseq = seq[ladd_id:uadd_id]
        
        gs, stiff = stiffgen_method(genseq, **stiffgen_args)
        if len(gs.shape) > 1:
            gs = gs.flatten()
        
        cl = (sid1 - ladd_id) * ndims
        cu = (uadd_id - sid2) * ndims

        lgs = len(gs)
        cgs = gs[cl : lgs - cu]
        cstiff = stiff[cl : lgs - cu, cl : lgs - cu]
                
        assert (
            len(cgs) == (id2 - id1) * ndims
        ), f"invalid length of gs ({len(cgs)=}). Should be {(id2-id1)*ndims=}"
        return cgs, cstiff

    # if periodic
    lseq = len(seq)
    extseq = str(seq)

    lid = sid1 - tail_size
    ladds = 0
    if lid < 0:
        ladds = int(np.ceil(-lid / lseq))
        extseq += ladds * seq
        lid += ladds * lseq

    uid = sid2 + tail_size
    uadds = 0
    if uid > lseq:
        uadds = int(np.ceil(uid / lseq))
        extseq += uadds * seq
    uid += ladds * lseq

    fseq = extseq[lid:uid]
    gs, stiff = stiffgen_method(fseq, **stiffgen_args)
    if len(gs.shape) > 1:
        gs = gs.flatten()
    
    cut = tail_size * ndims
    gs = gs[cut:-cut]
    stiff = stiff[cut:-cut, cut:-cut]

    assert (
        len(gs) == (id2 - id1) * ndims
    ), f"invalid length of gs ({len(gs)}), should be {(id2-id1)*ndims}"
    return gs, stiff


#######################################################################################
#######################################################################################
#######################################################################################
